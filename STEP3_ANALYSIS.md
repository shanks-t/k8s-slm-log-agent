# Step 3: Manifest Cleaning Analysis

**Date:** 2025-12-27
**Status:** ✅ Complete (No Action Required)

## Summary

**All existing manifests are already clean and production-ready.** No cleaning or normalization needed.

## Verification

### ✅ Workload Manifests (Already Clean)

**Location:** `workloads/llama-cpp/k8s/` and `workloads/log-analyzer/k8s/`

**Quality Checks:**
- ✅ No runtime metadata (creationTimestamp, resourceVersion, uid)
- ✅ No status sections
- ✅ Explicit namespace declarations
- ✅ Proper labels (app, component)
- ✅ Resource requests and limits
- ✅ Health checks (liveness + readiness probes)
- ✅ Node selectors + tolerations for 2-node cluster
- ✅ Numbered files (00-namespace, 01-pv, 02-pvc, 03-deployment, 04-service)

**Examples:**
- `workloads/llama-cpp/k8s/03-deployment.yaml` - Clean, well-documented
- `workloads/log-analyzer/k8s/02-deployment.yaml` - Clean, follows best practices

### ✅ Infrastructure Manifests (Already Clean)

**Location:** `platform/o11y/` and `platform/gateway/`

**Quality Checks:**
- ✅ Clean PV definitions with node affinity
- ✅ Helm values files (will become HelmReleases in Step 5)
- ✅ Gateway resources (GatewayClass, Gateway, HTTPRoute)
- ✅ Proper comments and documentation
- ✅ K3S-specific features documented

**Examples:**
- `platform/o11y/01-loki-storage.yaml` - Clean PV with detailed comments
- `workloads/llama-cpp/k8s/01-pv.yaml` - Clean PV with node affinity

## Flux Migration Strategy

Since manifests are already clean, we can:

1. **Use existing manifests as-is** for Flux structure
2. **Skip the cleaning phase** (exports were for reference only)
3. **Proceed directly to Step 4** (Define Flux repository structure)

## Manifest Organization

### Current Structure (Good)
```
workloads/
├── llama-cpp/k8s/
│   ├── 00-namespace.yaml
│   ├── 01-pv.yaml
│   ├── 02-pvc.yaml
│   ├── 03-deployment.yaml
│   └── 04-service.yaml
└── log-analyzer/k8s/
    ├── 00-namespace.yaml
    ├── 01-configmap.yaml
    ├── 02-deployment.yaml
    └── 03-service.yaml

platform/
├── o11y/
│   ├── 00-namespace.yaml
│   ├── 01-loki-storage.yaml
│   ├── 02-loki-values.yaml
│   ├── 03-alloy-values.yaml
│   ├── 04-grafana-values.yaml
│   ├── 06-tempo-storage.yaml
│   └── 07-tempo-values.yaml
└── gateway/
    ├── 01-gatewayclass.yaml
    ├── 02-envoy-proxy-config.yaml
    ├── 03-gateway.yaml
    ├── 04-test-httproute.yaml
    └── 05-grafana-httproute.yaml
```

### Target Flux Structure (Step 4)
```
clusters/homelab/
├── flux-system/           # Auto-generated by Flux bootstrap
├── infrastructure.yaml    # Root kustomization for infra
└── workloads.yaml         # Root kustomization for apps

infrastructure/
├── sources/               # HelmRepositories
├── controllers/           # Envoy Gateway HelmRelease
├── logging/               # Loki, Grafana, Tempo, Alloy HelmReleases
└── storage/               # PersistentVolumes

workloads/
├── llm/                   # llama-cpp manifests
└── log-analyzer/          # log-analyzer manifests
```

## Migration Path

1. Create `infrastructure/` and `workloads/` directories
2. Copy cleaned manifests to Flux structure
3. Convert `*-values.yaml` files to HelmRelease CRDs
4. Create kustomization.yaml files for each directory
5. Create Flux entry points in `clusters/homelab/`

## Decisions

| Decision | Rationale |
|----------|-----------|
| Use existing manifests | Already clean, no runtime metadata |
| Keep PVs in infrastructure/storage/ | Platform-level concern |
| Keep workloads separate | Clear separation of concerns |
| Convert Helm values to HelmReleases | Declarative Helm management |

## Next Steps

Proceed to **Step 4: Define Flux Repository Structure**

Create:
- `clusters/homelab/` directory
- `infrastructure/` directory with subdirectories
- `workloads/` directory with subdirectories
- Kustomization files for Flux

**Estimated Time:** 2 hours (as per roadmap)
